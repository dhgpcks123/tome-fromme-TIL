# 스프링 시큐리티
아파치 2.0 라이센스에 따라 공개된 오픈 소스 소프트 웨어이다. (java 8 이상의 환경에서 가능)

## 업데이트
1. MAJOR
- 이전 버전과 호환되지 않는 변경사항이 있을 때 올린다. 보통 최신 보안 방향성에 맞게 개선했을 때에 해당한다.
2. MINOR
    - 버전에서도 개선사항이 추가되지만, 좀 더 소극적인 업테이트이다.
3. PATCH
    - 버그를 수정하는 경우를 제외하면 전후 버전과 완전히 호환된다.

##Spring
1. SpringBoot에서는 Starter 지원
2. 오픈 소스 프로젝트처럼 메이븐 아티팩트로 의존성을 배포하기 때문에 그래들을 최우선으로 지원한다.
- 메이븐 아티팩트
    - group id, artifact id, version을 갖으며, 이 세가지가 모여 artifact를 유일하게 구분하게 된다.

스프링 부트 없으 스프링 시큐리티 사용 시 스프링 스큐리티의 BOM으로 전체 프로젝트의 버전을 통일하는게 좋다.
```
plugins {
    id "io.spring.dependency-management" version "1.0.6.RELEASE"
}

dependencyManagement {
    imports {
        mavenBom 'org.springframework.security:spring-security-bom:5.3.2.RELEASE'
    }
}
```

## 암호화
스프링 시큐리티는 기본적으로 PasswordEncdoer 인터페이스에서 단방향 암호화를 제공한다.

단방향 암호화
- 암호화만 가능 복호화 불가능
- 해쉬값을 통해 암호화가 되지만 동일한 암호를 암호화 반복할 경우 일정 부분이 동일함
- 플레인 데이터와 해쉬 데이터가 서로 일치한지 확인은 가능
- 해쉬값 반복을 통해 레인보우 테이블을 제작가능
- 이를 방지하기 위하여 N번 해쉬, 솔트가 존재
- N번 해쉬의 경우 코드를 조금만 볼 경우 몇번 돌렸는지 파악가능
- 솔트값의 경우 암호화 마다 개별로 필요하며, 암호화한 데이터와 마찬가지로 DB에 저장

단방향 암호화는 실제로 어떤 값이 존재하는지 알 수 없기에 주로 비밀번호 값을 암호화 해서 관리하며, 해당 비밀번호는 어떤 값으로 암호화 되었는지 알 수 없기에 비밀번호가 뭔지 모를경우 통채로 비밀번호를 변경한다.

양방향 암호화
- 암호화, 복호화 둘다 가능
- 어떤 알고리즘을 사용했냐에 따라 쉽게 암, 복호화 해서 데이터 취득가능

사용자에게 보여주기 위한 전화번호, 주민등록번호 같은 경우 양방향 암호화로 저장한다.

# CSRF
사이트간 요청위조 공격방어를 종합적으로 지원한다.
- CSRF 공격이 가능한 이유로는 웹 사이트의 HTTP요청과 공격하는 웹사이트의 요청이 완전히 동일하기 때문이다.

###CSRF 방어하기 위하여
동기화 토큰패턴, 세션 쿠키의 SameSite 속성 지정 모두 safeHTTP 멱등성을 보장해야 한다. (POST, PUT, DELETE)
- SameSite는 SpringSecurity가 지원하지 않음

###가장 보편화된 CSRF 방어하기 위한 기술
동기화 토큰 패턴 방법이며, HTTP요청에 세션 쿠키와 별도인 랜덤 토큰을 추가한 이후 HTTP 요청 시 CSRF 토큰을 찾아 실제 HTTP 요청에 있는 CSRF 토큰과 비교한다. (멱등성이 보장되어야 하며, GET 방식 시 토큰이 유출될 수 있음)

### 언제 CSRF?
CSRF는 일반 사용자가 브라우저에서 처리할 수 있는 모든 요청에 CSRF 방어를 권장하는 바이다. 만들고 있는 서비스를 브라우저가 아닌 다른 클라이언트에서만 사용한다면 CSRF 방어를 비활성화 해도 된다.

###JSON CSRF 보호
어플리케이션에서 Content-Type을 검증하지 않았다면 바로 취약점 공격에 노출된다. 스프링 MVC 어플리케이션은 Content-Type을 검증하더라도, 설정에 따라 다음과 같이 .json으로 끝나는 URL에선 여전히 공격에 취약할 수 있다.

###CSRF and Stateless Browser Application
어플리케이션에 상태가 없더라도 안전하지는 않는다. 사용자가 웹 브라우저 요청으로 수행하는 작업이 없다고 하더라도 CSRF 공격에 노출되어 있는 것은 동일하다.
```
예를 들어 인증을 위한 모든 상태를 JSESSIONID 대신 커스텀 쿠키에 저장하는 어플리케이션에서
 CSRF 공격을 받으면 JSESSIONID 쿠키가 전송된 것과 동일하게 커스텀 쿠키도 요청에 포함되기에 CSRF 공격에 취약하다.

기본 인증을 사용하는 어플리케이션도 동일하게 JSESSIONID 쿠키가 전송된 것과 동일하게
 브라우저가 모든 요청에 사용자 이름과 비밀번호를 추가하기에 CSRF 공격에 노출되어 있다.
```

## CSRF Considerations

### 로그인
로그인 요청 위조를 막으려면 로그인 HTTP 요청을 CSRF 공격으로부터 보호해야 한다. 악의적으로 다른 사람의 민감 정보를 볼 수 없게 하려면 반드시 로그인 요청 위조를 막아야 한다.
공격 순서
1. 악의적인 사용자가 본인의 credentital로 CSRF 로그인을 수행 (이제 희생자는 악의적인 계정으로 인증됨)
2. 악의적인 사용자는 트릭을 써서 희생자가 취약 사이트에 방문하고, 민감한 정보를 입력하게 만듬
3. 이 정보는 악의적인 사용자 계정에서 작성된 정보이기에 악의적인 사용자는 자기 credentital로 로그인한 뒤 희생자의 민감한 정보를 조회할 수 있다.
   단점으로는 세션이 타임아웃될 경우 사용자가 요청을 거절 당하는 불편함을 겪을 수 있다는 것이다. (요즘 사용자들도 시간이 지나면 로그인이 풀린다는것을 어느정도 알고있을거 같은데...)

### 로그아웃
로그인과 동일하게 로그아웃도 HTTP요청을 CSRF 공격으로 부터 보호해야함

### Multipart CSRF 보호
1. **Place CSRF Token in the Body** 첫 번째 방법은 요청 body에 실제 CSRF 토큰을 추가하여 body를 읽고 나서 권한을 부여하는 방법이다. (권장)
2. form action속성에 쿼리 파라미터로 CSRF를 넣는 방법 쿼리 스트링에 유출될 수 있는 단점이 존재

## 시큐리티 HTTP

### ResponseHeaders
 - 생략
##HTTP
스태틱 리소스를 포함한 모든 HTTP 통신은 TLS로 보호해야 한다.
```인터넷 커뮤니케이션을 위한 개인정보와 데이터 무결성을 제공하는 보안 프로토콜 (SSL 기반 기술)```
스프링 시큐리티는 프레임워크이기에 HTTP 커넥션을 직접 다루지 않으며, HTTPS를 직접적으로 지원하지 않지만 도와줄 수 있는 기능은 제공한다.
